/* Typescript file generated by genType. */

// tslint:disable-next-line:no-var-requires
const CreateBucklescriptBlock = require('bs-platform/lib/js/block.js');

// tslint:disable-next-line:no-var-requires
const TypesBS = require('./Types.bs');

import {list} from '../../src/shims/ReasonPervasives.shim';

// tslint:disable-next-line:interface-over-type-literal
export type t = number;

export const someIntList: list<number> = TypesBS.someIntList;

export const map: <T1,T2>(_1:(_1:T1) => T2, _2:list<T1>) => list<T2> = TypesBS.map;

// tslint:disable-next-line:max-classes-per-file 
export abstract class TypeWithVarsA<x,y> { protected opaque!: x | y }; /* simulate opaque types */

export const A: <x,y>(_1:x, _2:y) => TypeWithVarsA<x,y> = function _(Arg1, Arg2) { return CreateBucklescriptBlock.__(0 as any, [Arg1, Arg2]) }

// tslint:disable-next-line:max-classes-per-file 
export abstract class TypeWithVarsB<z> { protected opaque!: z }; /* simulate opaque types */

export const B: <z>(_1:z) => TypeWithVarsB<z> = function _(Arg1) { return CreateBucklescriptBlock.__(1 as any, [Arg1]) }

export type typeWithVars<x,y,z> =
  | TypeWithVarsA<x,y>
  | TypeWithVarsB<z>;

// tslint:disable-next-line:interface-over-type-literal
export type tree = {
  label: string, 
  left?: tree, 
  right?: tree
};

export const swap: (_1:tree) => tree = TypesBS.swap;

// tslint:disable-next-line:interface-over-type-literal
export type selfRecursive = {self: selfRecursive};

// tslint:disable-next-line:interface-over-type-literal
export type mutuallyRecursiveA = {b: mutuallyRecursiveB};

// tslint:disable-next-line:interface-over-type-literal
export type mutuallyRecursiveB = {a: mutuallyRecursiveA};

export const selfRecursiveConverter: (_1:selfRecursive) => selfRecursive = function _(Arg1) { const result = 
/* WARNING: circular type selfRecursive. Only shallow converter applied. */
  TypesBS.selfRecursiveConverter([Arg1.self]); return {self:result[0]} };

export const mutuallyRecursiveConverter: (_1:mutuallyRecursiveA) => mutuallyRecursiveB = function _(Arg1) { const result = 
/* WARNING: circular type mutuallyRecursiveB. Only shallow converter applied. */
  TypesBS.mutuallyRecursiveConverter([[Arg1.b.a]]); return {a:{b:result[0][0]}} };
